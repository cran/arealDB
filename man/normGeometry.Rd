% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/normGeometry.R
\name{normGeometry}
\alias{normGeometry}
\title{Normalise geometries}
\usage{
normGeometry(
  input = NULL,
  pattern = NULL,
  query = NULL,
  thresh = 10,
  outType = "gpkg",
  priority = "ontology",
  beep = NULL,
  simplify = FALSE,
  update = FALSE,
  verbose = FALSE
)
}
\arguments{
\item{input}{[\code{character(1)}]\cr path of the file to normalise. If this
is left empty, all files at stage two as subset by \code{pattern} are
chosen.}

\item{pattern}{[\code{character(1)}]\cr an optional regular expression. Only
dataset names which match the regular expression will be processed.}

\item{query}{[\code{character(1)}]\cr part of the SQL query (starting from
WHERE) used to subset the input geometries, for example \code{where NAME_0
= 'France'}. The first part of the query (where the layer is defined) is
derived from the meta-data of the currently handled geometry.}

\item{thresh}{[\code{integerish(1)}]\cr}

\item{outType}{[\code{character(1)}]\cr the output file-type, see
\code{\link{st_drivers}} for a list. If a file-type supports layers, they
are stored in the same file, otherwise the different layers are provided
separately. For an R-based workflow, \code{"rds"} could be an efficient
option.}

\item{priority}{[\code{character(1)}]\cr how to match the new geometries with
  the already harmonised database. This can either be

  \itemize{
    \item \code{"spatial"}: where all territories are intersected spatially or
    \item \code{"ontology"}: where territories are matched by comparing their
    name with the ontology
    and those that do not match are intersected spatially,
    \item \code{"both"}: where territories are matched with the ontology and
    spatially, and conflicts are indicated
  }}

\item{beep}{[\code{integerish(1)}]\cr Number specifying what sound to be
played to signal the user that a point of interaction is reached by the
program, see \code{\link[beepr]{beep}}.}

\item{simplify}{[\code{logical(1)}]\cr whether or not to simplify geometries.}

\item{update}{[\code{logical(1)}]\cr whether or not the physical files should
be updated (\code{TRUE}) or the function should merely return the geometry
inventory of the handled files (\code{FALSE}, default). This is helpful to
check whether the metadata specification and the provided file(s) are
properly specified.}

\item{verbose}{[\code{logical(1)}]\cr be verbose about what is happening
(default \code{FALSE}). Furthermore, you can use
\code{\link{suppressMessages}} to make this function completely silent.}
}
\value{
This function harmonises and integrates so far unprocessed geometries
  at stage two into stage three of the geospatial database. It produces for
  each main polygon (e.g. nation) in the registered geometries a spatial file
  of the specified file-type.
}
\description{
Harmonise and integrate geometries into a standardised format
}
\details{
To normalise geometries, this function proceeds as follows:
  \enumerate{ \item Read in \code{input} and extract initial metadata from
  the file name. \item In case filters are set, the new geometry is filtered
  by those. \item The territorial names are matched with the gazetteer to
  harmonise new territorial names (at this step, the function might ask the
  user to edit the file 'matching.csv' to align new names with already
  harmonised names). \item Loop through every nation potentially included in
  the file that shall be processed and carry out the following steps:
  \itemize{ \item In case the geometries are provided as a list of simple
  feature POLYGONS, they are dissolved into a single MULTIPOLYGON per main
  polygon. \item In case the nation to which a geometry belongs has not yet
  been created at stage three, the following steps are carried out:
  \enumerate{ \item Store the current geometry as basis of the respective
  level (the user needs to make sure that all following levels of the same
  dataseries are perfectly nested into those parent territories, for example
  by using the GADM dataset) } \item In case the nation to which the geometry
  belongs has already been created, the following steps are carried out:
  \enumerate{ \item Check whether the new geometries have the same coordinate
  reference system as the already existing database and re-project the new
  geometries if this is not the case. \item Check whether all new geometries
  are already exactly matched spatially and stop if that is the case. \item
  Check whether the new geometries are all within the already defined
  parents, and save those that are not as a new geometry. \item Calculate
  spatial overlap and distinguish the geometries into those that overlap with
  more and those with less than \code{thresh}. \item For all units that did
  match, copy gazID from the geometries they overlap. \item For all units that
  did not match, rebuild metadata and a new gazID. } \item If update = TRUE,
  store the processed geometry at stage three.} \item Move the geometry to
  the folder '/processed', if it is fully processed.}
}
\examples{
if(dev.interactive()){
  library(sf)

  # build the example database
  makeExampleDB(until = "regGeometry", path = tempdir())

  # normalise all geometries ...
  normGeometry(nation = "estonia", update = TRUE)

  # ... and check the result
  st_layers(paste0(tempdir(), "/adb_geometries/stage3/Estonia.gpkg"))
  output <- st_read(paste0(tempdir(), "/adb_geometries/stage3/Estonia.gpkg"))
}
}
\seealso{
Other normalise functions: 
\code{\link{normTable}()}
}
\concept{normalise functions}
